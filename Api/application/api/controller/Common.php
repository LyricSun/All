<?php
/**
 * Created by PhpStorm.
 * User: information
 * Date: 2017/11/29
 * Time: 上午10:20
 */
//命名空间
namespace app\api\controller;
//使用要用到的类
use app\common\lib\exception\ApiException;
use think\Cache;
use think\Controller;
//common类继承Controller类
class Common extends Controller{
    //common类是用来验证的,所以需要初始化
    protected function _initialize()
    {
        //调用验证方法
//        $this->checkSign();
        parent::_initialize(); // TODO: Change the autogenerated stub
    }
    //验证方法
    public function checkSign(){
        //获取请求头部的信息
        $header = request()->header();
        //下面三个参数必须携带
        //如果缺少参数sign,则抛出异常,状态码400,因为是因参数错误而导致服务器端无法继续处理
        if (empty($header['sign'])){
            throw new ApiException('缺少sign',400, 1002);
        }
        //如果缺少参数did,则抛出异常,状态码400,因为是因参数错误而导致服务器端无法继续处理
        if (empty($header['did'])){
            throw new ApiException('缺少did',400);
        }
        //如果缺少参数time,则抛出异常,状态码400,因为是因参数错误而导致服务器端无法继续处理
        if (empty($header['time'])){
            throw new ApiException('缺少time',400);
        }

//获取body中参数,param可获取当前请求的变量
        $param = input('param.');
        //把头部中did和time两个参数加到变量param中,便于排序
        $param['did'] = $header['did'];
        $param['time'] = $header['time'];

        //加密算法,先排序,然后进行URL编码,然后MD5加密,然后把字符编程大写,再拼接一个密钥,然后再进行MD5加密
        ksort($param);

        $str = md5(strtoupper(md5(http_build_query($param))) . config('app.md5_code'));
        //把加密后的结果与请求头部中的参数sign进行对比,如果不相等,则认证失败,抛出异常,状态码401,因为401表示认证类型的错误
        if ($str != $header['sign']){
            throw new ApiException('认证失败',401,1001);
        }

        //但这样还不够安全,因为第三方可能直接抓取前段加密好的sign和数据,然后以相同的路由携带相同的参数想后端请求数据,这样数据也不安全,所以加上时间戳,再限制从前端发送请求到后端的时间,比如限制为10秒,超过10秒的就可以不返回数据,而且通过该时间戳想请求数据也是不行的,因为时间戳变的话,sign也会变
        //判断是否查过限制时间,如果超过那么抛出异常
        if (time() - $header['time'] > 10){
            throw new ApiException('认证超时');
        }

        //因为即使有了sign和时间戳还是不安全,所以要在保证sign的唯一性,前端每一次发送的请求先检测,如果其中的sign缓存中没有,就会被保存到缓存中,并且返回请求数据,如果缓存中已存在,证明不是第一次,所以不返回请求的数据,并抛出异常
        if (Cache::get($header['sign'])){
            throw new ApiException('签名不具备唯一性',401);
        }

        Cache::set($header['sign'],'1',config('app.sign_cache_time'));



    }
}